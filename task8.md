### Шаг 4. Создаем формальные спецификации АТД
1. **Element** - АТД для всех возможных типов элементов: 

	1.1 **BaseElement** - класс, реализующий АТД **Element**, представляет обычный элемент (один из букв A, B, C, D, E);
	
	1.2 **BonusElement** - класс, реализующий АТД **Element**, представляет бонус-элемент, сценарии использования которого отличается от обычного.

2. **ElementFactory** - фабрика для генерации случайных элементов;
	
3. **Field** - АТД для разных типов полей:

	3.1 **Grid** - класс, реализующий АТД **Field**, представляющий конкретную реализацию игрового поля в виде матрицы размером 8х8.

	(Теоретически в перспективе могут быть добавлены более сложные типы игровых полей, в нашей задаче не предусмотрены.)

4. Далее предлагается использовать паттерн "Strategy" для проверки состояния игрового поля на соответствие правилам, на каждой правило предлагается определить свой интерфейс:

	4.1 **MoveAvailabilityStrategy** - интерфейс для проверки наличия ходов;

	4.2 **CombinationDetectionStrategy** - интерфейс для обнаружения комбинаций на игровом поле;

	4.3 **UserInputValidationStrategy** - интерфейс для проверки валидности пользовательского ввода.

5. Паттерн "Observer" предлагается использовать в следующих интерфейсах:

	5.1 **StatisticsObserver** - для обновления статистики;

	5.2 **FieldDisplayObserver** - для обновления игрового поля;

	5.3 **ReportObserver** - для создания уведомлений пользователю.

6. **Statistics** - класс для хранения очков и ходов.

7. **Report** - класс для генерации сообщений пользователю.

8. **Game** - класс управления игрой.

### Шаг 5. Уточняем формальные спецификации АТД

1. Абстрактный класс **Element**:

	- Возможные поля: symbol (так будет выведен для пользователя), value (стоимость элемента при обнаружении комбинации, засчитывается в очки пользователя).
	- Запросы: получить символ, получить стоимость.
	
2. Класс **ElementFactory**:

	- Запросы: получить случайный элемент (можно добавить долю вероятности для получения бонусного элемента).
	
3. Класс **Field**:

	- Возможные поля: массив elements.
	- Запросы: получить символ по координатам, вывести текущее состояние игрового поля;
	- Команды: заполнить пустые ячейки игрового поля.

4. Интерфейс **MoveAvailabilityStrategy**:

	- Возможный метод: логическая переменная isMoveAvailable.

5. Интерфейс **CombinationDetectionStrategy**:

	- Возможный метод: detectCombination.

5. Интерфейс **UserInputValidationStrategy**:

	- Возможный метод: логическая переменная isValidInput.
	
6. Интерфейс **StatisticsObserver**:

	- Возможный метод: updateStatistics.

7. Интерфейс **FieldDisplayObserver**:

	- Возможный метод: displayField.

8. Интерфейс **ReportObserver**:

	- Возможный метод: sendReport.

9. Класс **Statistics**:

	- Возможные поля: score, historyOfMoves.
	- Запросы: получить очки, получить историю ходов.
	- Команды: добавить очки, записать ход в историю ходов.

10. Класс **Report**:

	- Возможные поля: message.
	- Команды: отправить уведомление.